worker_processes auto;

# Write the PID file into the world-writable /tmp directory.  The default
# location (/run/nginx.pid) is not writable when running in a read-only
# container with dropped privileges.  By moving the pid to /tmp we avoid
# permission errors during startup.
pid /tmp/nginx.pid;

events {
    # Set sensible default worker connections.  The 'auto' directive above
    # will scale the number of workers based on CPU cores.
    worker_connections 1024;
}

http {
    # Include MIME types for static assets.
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    # Improve file transfer performance.
    sendfile        on;
    # Connection timeout settings.
    keepalive_timeout 65;

    # Place temporary files (client bodies, proxy cache, etc.) in /tmp.  This
    # directory is mounted as a writable tmpfs in the container definition, so
    # Nginx can write to it even when the root filesystem is read-only.
    client_body_temp_path /tmp/client_temp;
    proxy_temp_path       /tmp/proxy_temp_path;
    fastcgi_temp_path     /tmp/fastcgi_temp;
    uwsgi_temp_path       /tmp/uwsgi_temp;
    scgi_temp_path        /tmp/scgi_temp;

    server {
        # Listen on port 80 inside the container.  Docker maps this to host
        # port 8080 via the compose configuration.
        listen       80 default_server;
        server_name  _;

        # Serve files from the static HTML directory.  The frontend build
        # copies compiled assets into this location.
        root /usr/share/nginx/html;
        index index.html index.htm;

        # Try to serve requested files directly; fall back to a 404 if
        # the file doesn't exist.  For single-page applications, you may
        # consider redirecting unmatched routes to index.html instead.
        location / {
            try_files $uri $uri/ =404;
        }
    }
}